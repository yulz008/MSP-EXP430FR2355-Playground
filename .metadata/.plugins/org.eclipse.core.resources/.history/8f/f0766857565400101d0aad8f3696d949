#include <msp430.h> 
#include "w5500_spi.h"
#include "wizchip_conf.h"
#include "socket.h"
#include <stdio.h>

static void PHYStatusCheck(void);
static void PrintPHYConf(void);
void delay_ms(unsigned int ms);

// Static config Mode
wiz_NetInfo gWIZNETINFO = {
        .mac = { 0x80, 0x34, 0x28, 0x74, 0xA5, 0xCB },//MSB - LSB
        .ip ={ 192, 168, 1, 111 },   // embedded host static ip address
        .sn = { 255, 255, 255, 0 },  // Subnet Mask
        .gw ={ 192, 168, 1, 1 },     // Gateway
        .dns = { 8, 8, 8, 8 },       // google dns
        .dhcp = NETINFO_STATIC };    // dhcp disabled, we are static config mode

uint8_t destination_ip[] = {192, 168, 1, 100};
uint16_t destination_port = 4000;

int main(void)
{
	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	
	W5500Init();

	// this is a central function that let us execute several commands on the driver
	ctlnetwork(CN_SET_NETINFO, (void*) &gWIZNETINFO);

     // Configure PHY by software
      wiz_PhyConf phyconf;

      phyconf.by=PHY_CONFBY_SW;
      phyconf.duplex=PHY_DUPLEX_FULL;
      phyconf.speed=PHY_SPEED_10;
      phyconf.mode=PHY_MODE_AUTONEGO; //best to go with auto-negotiation

      ctlwizchip(CW_SET_PHYCONF, (void*) &phyconf);//PHY Configuration Comman

	PHYStatusCheck();
	PrintPHYConf();

    printf("Connected to Server!\r\n");

    // Socket Creation
    // 1st param: sockets,  support 8 [0-7]
    // 2nd param: protocol, w550 supports 2 protocols and socket type - TCP or UDP
    // 3rd param: port, for creating a server we specify this. but since we are specifying a client we set it to "0"
    // 4th param: flag, for simple application we set this to 0.
    if(socket(1, Sn_MR_TCP, 0, 0)==1)
    {
        printf("\r\nSocket Created Successfully!");
    }
    else
    {
        printf("\r\nCannot Create Socket!");
        while(1);
    }


    // Established Connection
    printf("\r\nConnecting to server: %d.%d.%d.%d @ TCP Port: %d",destination_ip[0],destination_ip[1],destination_ip[2],destination_ip[3],destination_port);
    int onConnect = connect(1, destination_ip, destination_port);
    if(onConnect==SOCK_OK)
    {
        printf("\r\nConnected with Server.");
    }
    else
    {
        //failed
        printf("\r\nCannot Connect to Server!");
        while(1);
    }

    while (1)
    {
       // return value of the send() function is the amount of data sent
       if(send(1, "Hello Server! From Embedded Client!\r\n", 37) <= SOCK_ERROR)
       {
           printf("\r\nSending Failed!");
       }
       else
       {
           printf("\r\nSending Success");
       }
       delay_ms(1000);
    }



	return 0;
}


void delay_ms(unsigned int ms)
{
    while (ms--)
    {
        __delay_cycles(1000); // For 1MHz MCLK = ~1ms
    }
}



static void PHYStatusCheck(void)
{
    uint8_t tmp;

    do
    {
        printf("\r\nChecking Ethernet cable presence ...");

        ctlwizchip(CW_GET_PHYLINK, (void*) &tmp);

        if(tmp == PHY_LINK_OFF)
        {
            printf("No Cable Connected!");
            delay_ms(1500);
        }
    }
    while(tmp == PHY_LINK_OFF);

    printf("\r\nGood! Cable got connected!");
}


static void PrintPHYConf(void)
{
    wiz_PhyConf phyconf;

    ctlwizchip(CW_GET_PHYCONF, (void*) &phyconf);

    if(phyconf.by == PHY_CONFBY_HW)
    {
       printf("\r\nPHY Configured by Hardware Pins");
    }
    else
    {
        printf("\r\nPHY Configured by Registers");
    }

    if(phyconf.mode == PHY_MODE_AUTONEGO)
    {
       printf("\r\nAutonegotiation Enabled");
    }
    else
    {
       printf("\r\nAutonegotiation NOT Enabled");
    }

    if(phyconf.duplex == PHY_DUPLEX_FULL)
    {
        printf("\r\nDuplex Mode: Full");
    }
    else
    {
       printf("\r\nDuplex Mode: Half");
    }

    if(phyconf.speed == PHY_SPEED_10)
    {
        printf("\r\nSpeed: 10Mbps");
    }
    else
    {
       printf("\r\nSpeed: 100Mbps");
    }
}



